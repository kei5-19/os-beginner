# 18日目

<!-- mtoc-start -->

- [1. ファイルアロケーションテーブル](#1-ファイルアロケーションテーブル)
- [2. 初アプリ](#2-初アプリ)
- [3. ~~C++~~ Rust で計算機](#3-c-rust-で計算機)

<!-- mtoc-end -->

## 1. ファイルアロケーションテーブル

教科書のままの実装だと、`cat` の引数にないファイルを指定されたときに、
ディレクトリ内を最後まで探索しているが、アホみたいに時間がかかるため、
エントリーが終わったところで探索を中断している。

## 2. 初アプリ

ビルドシステムが教科書とちょっと違うので、ビルドのために変更した場所が少し違う。

## 3. ~~C++~~ Rust で計算機

教科書通りに実装したが、動かない。
そういえば実行ファイルには配置場所とかは書かれているが、
その通りに配置するのはローダーの仕事なのを忘れていた。
つまり、ファイルで見たときに、ELF ヘッダに書かれているエントリーポイントの場所に
エントリーポイントが置かれているわけではない。

ということで、プログラムヘッダを読んで、実行可能フラグが立っている場所のオフセットを得ることにしたが、
それでも動かない。

ただ理由は判明したので、書いていく。

まず普通 ELF ファイルは特定のセグメント群を特定の仮想アドレスに再配置することを要求すること。
これを解決するには教科書の後半で実装することになるページングの設定をしなければならない。
（正確には今も最低限の設定はされているが、もっとちゃんと設定しないといけない。）

ただ今のままでも解決策はある。
どのセグメントがファイルのオフセットいくつのとこにあるかという情報はプログラムヘッダに書かれているので、
実行可能セグメントのプログラムヘッダを見つけて読みその分を足せば良い。
けどこれだけではダメ。
なにがダメかと言うと、エントリーポイントは実行可能セグメントの先頭というわけではないので、

```
(セグメントのオフセット) + ( (エントリーポイント) - (セグメントの仮想アドレス) )
```

を計算しないといけない。

これで解決するかなと思ったが、これでもダメ。
デバッガを動かしてみてみると、

```
call [rip + addr]
```

のような命令があった。
`rip + addr` 自体は `rip` からの相対アドレスになっているので問題ないが、
`rip + addr` というアドレス自体が実行可能セグメントではなく別のセグメントのアドレスなせいで、
またオフセットと仮想アドレスが違うという問題が発生している。
（正確にはセグメントごとに仮想アドレスとオフセットの差が異なるのが問題）

教科書はこういう面倒を回避するためとして、リンク時に `--image-base=0` というのを指定して解決していると
説明しているが、恐らくリンカの種類などの違いでそれをしても同じ問題が起こる。

ということで仕方なくカーネルを読み込むときと同じ対処法、
もう1度ファイルの中身を、それぞれの仮想アドレスの相対位置が正しくなるように再配置する、
を取ることにした。
（恐らく命令はどこに読み込まれてもいいように、
現在のプログラムカウンタからの相対位置を使うようになっているので、差が正しくなるようにさえすればいいはず）

ということで再配置で解決しようとしたが、
なんか Rust は static コンパイルすると、コンパイラ組み込みの関数
（実際埋め込まれているのかはわからないが、デバッグ情報で関数名に `compiler_builtin` 的なことが書いてった）
を使うときに相対アドレスでなく絶対アドレスのジャンプ命令を出力してきたので、
ページングを使わないと解決できない。

一応 PIE（Position Independent Executable）にすることで解決できないこともないが、
再配置が大変すぎる（メモリの何箇所かに指定された値を入れないといけなかったりする）。
どうしようかなと教科書をめくったら、次の章でページング設定をやるっぽいので、
一旦諦めて教科書同様に C++ を使うことに。
ただ、C++ を使っても結局リンカーがファイル内のオフセットと仮想アドレスが違う出力を出してくるので、
さっき書いたような変更は必要になる。
（カーネルのときも同じような問題おきたし、やっぱリンカのバージョンの問題なんかな）
