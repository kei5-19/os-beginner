# 8日目

## 1. メモリ管理

メモリ管理がなぜ必要かの説明が行われている。
まあめちゃくちゃ簡単に言えば、C だったら `mallc`、C++ だったら `new`、
Java（例外あり）とか Python だったらインスタンスを作るたびにメモリ確保が行われる。
そういうときのために必要。

## 2. UEFI メモリマップ（osbook_day08a）

メインメモリの状況を把握しようという話。
これは [mikan-loader](../mikan-os/mikan-loader/) のところで既に取得している。
そこではファイルに保存するということをやった。

なので、それを [kernel](../mikan-os/kernel/) に渡してやればいいだけ。
ちゃんと渡せているかの確認として、使用可能領域だけをコンソールに表示させた。
ファイルに保存されているデータと見比べたところ、ちゃんと一致していそうだった。
（全部ちゃんと確認するのは面倒なので、していない）

あとは EDK II の方の `MemoryDescriptor` はバージョンが変わったときにも対応できるようにしているのに対し、
~~[uefi-rs](https://docs.rs/uefi/0.26.0/uefi/index.html) はパッと見対応しているように見えないので、
そこだけは注意したほうが良さそう~~ と思ったけど、少しソースコード読んでみたところ、ちゃんと対処してそう。

## 3. データ構造の移動（osbook_day08b）

メモリ領域が使用可能かどうかを判定する `memory_map::is_available()` 関数を作成。
これは§2で表示したもののうちのどれかかどうかを判定するだけなので簡単。

あとは今後の方針が書かれていた。

最終的な目標はメモリ管理を行うことだが、
その前に UEFI が用意してくれたデータが使用可能領域にあるらしいので、
その移動をさせるらしい。

移動すべきデータは

1. スタック領域
2. GDT (Global Description Table)
3. ページテーブル

の3つらしい。

UEFI 終了直後のカーネルは UEFI が作ってくれたスタック領域を使わせてもらっているらしい。

あと、GDT は [day7](./07.md) で言っていたようにセグメンテーションの機能が弱くなっているので、
あまり使わないが、必要最低限の設定はしないといけないらしい。
x86 のときの設定も結構雑だったので、なんとなくそれと似たような感じかなと想像している。

あとはページングテーブル。
ページングは大事な機能で、x86 でも設定したが、
x64 ではセグメンテーションの機能をほとんどページングに投げていて、
ページングがメモリ管理の主役になっているっぽい？

まあ、x86 のときもページングのほうがしっかりと設定したし、
セグメンテーションでできることはだいたいページングでできるし、
あとからの割り当てとかも簡単そうだしで、
なんとなく「そうなってもしゃあないな」という感じはする。

## 4. スタック領域の移動

まず1つ目のスタック領域の移動の実装。

まず、カーネル用のスタックをグローバル領域に用意する。
すると、スタックはカーネル領域に含まれることになる。

そして、`kernel_entry` を変更して、そこでは `rsp` の変更のみを行い、
メインの処理（元々の `kernel_entry`）を呼び出すようにする。

このときに、以前のスタック領域は失われてしまうから、
今までのようにでかい構造体をそのまま渡すことはできなくなる。

そこで、まずは参照のみを渡すようにし、カーネルの処理でコピーを行う。
ここでコピーを行わないと、いずれ使っていない領域として UEFI のスタックが割り当てられた際に詰む。

このときに、`uefi-rs` の `MemoryMap` はコピーが不可能な問題が発生したが、
一旦 `MemoryMap::entries()` を用いて全ての `MemoryDescriptor` を読み、
それを自前で用意した配列にコピーすることで解決した。

## 5. セグメンテーションの設定

（本当に今更なんですが、）OS 作成では当たり前のようにビット操作が多いので、
`bitfield::BitField` という、ビット操作を行うようのトレイトを自作し、
（マクロで）整数型に実装するようにした。

GDT の設定をするということで、読み進めていたところ、
x64 では `base`（セグメントの開始アドレス）と `limit`（セグメントのバイト数）が
無視されるとかいうとんでもない情報が書いてあった。
どのセグメントを指定しているかどうかしか気にしないということか。
タスクの種類で大雑把にセグメントを選んで、
その上で適切なページングを設定して、
1つのタスクごとにページを振っていくみたいな使い方をするんかな？
（ここらへんの整理のために復習として
[作って理解するOS x86系コンピュータを動かす理論と実装](https://gihyo.jp/book/2019/978-4-297-10847-2)
を読み返した）

あとディスクリプタの詳細も [x86_descriptor.rs](../mikan-os/kernel/src/x86_descriptor.rs) にコメントとして書いた。
これも上述の教科書と、
[Global Descriptor Table](https://wiki.osdev.org/Global_Descriptor_Table) を読んだ。

セグメントレジスタについても、DS, ES レジスタは64ビットモードでは使われないらしい。
FS, GS レジスタ、x86 でもあったらしいが、今まで使ったことなかったのでなにに使うかも知らない。
この2つは64ビットモードでも使えるらしい。
CS, SS はまあ少なくともリングレベルごとに変えるやろしいるやろなあ。
と思ったら、SS はシステムコール以外では使われてないらしい。
ページング様々ってことかな？

## 6. ページングの設定

x86 のときページングは20ビットで、先頭10ビットはページングディレクトリを、
後ろ10ビットはページングテーブルという参照をしていたが、
なんか x64 では x86 の2階層から進化して

- ページマップレベル4テーブル（PML4 table）
- ページディレクトリポインタテーブル（PDP table）
- ページディレクトリ
- ページテーブル

の4階層になっているらしい。

ページング自体の説明は19章でやるらしいので、ここでは簡単に必要最低限な設定をするだけ。

ここで、ラベルのアドレスを読み込むときに、教科書と Rust で文法に違いがあることに気づいた。
セグメンテーションの設定のとこでも「あれ？」とはなっていたが、
2回目で、他のと重なったのもあって確信に変わった。

調べたところ、教科書が nasm 用のアセンブリで書かれている（これは知っていた）のに対し、
Rust のインラインアセンブリは gas（GNU as）用（のintel 記法）のもので書かないといけないらしい。
多分そこが違うせいで、nasm では

```asm
mov rax, .label
```

とできるところを、gas では

```asm
lea rax, .label
lea rax, [.label]
```

（どっちでも良い）のようにしないといけないらしい。

あとは写経みたいなもんやろと思ったんですが、なんか通りませんでした。
デバッグとか色々していたら、1ビットコピーしていなかったり、
0x83 と OR を取るのに、0x03 と OR を取っていたりしていただけで悲しかった。。

## 7. メモリ管理に挑戦（osbook_day08c）

これがしたかった。

といってもそこまで大変なものはしてないっぽい。
本当の OS ってこういう感じの割り当てしているのか分からない。

教科書との違いでいうと、これでもうヒープを使えるようにしたかったので、
`#[global_allocator]` という属性を使って、ヒープを使う構造体（`Vec` とか）を使えるようにした。

ちょっと調べてみたところ、Modern Operating Systems, Global Edition（ISBN: 9781292459660）
とか読むと良さそうかもしれない。
（タネンバウム色々書きすぎやろ。すごい。）

## 以後の展望

次は第9章「重ね合わせ処理」らしいですが、コードが結構ぐちゃぐちゃしてきたし、
メモリアロケータの実装もしたから、
9章に入る前に、ヒープ使ったり、Rust っぽい構造を使ったりして
リファクタリングをしたいと思います。
