# 15日目

<!-- mtoc-start -->

- [1. ウィンドウ描画はメインスレッドで](#1-ウィンドウ描画はメインスレッドで)
- [2. アクティブウィンドウ](#2-アクティブウィンドウ)
- [3. ターミナルウィンドウ](#3-ターミナルウィンドウ)

<!-- mtoc-end -->

## 1. ウィンドウ描画はメインスレッドで

ここを早くやりたかった。
この実装で描画のデッドロックがなくなるはず……。

今の実装だとウィンドウのアクセスに `LAYER_MANAGER` を使うので、
また引数を増やしてそこから `Option<&mut Window>` を渡すことに。
だいぶ強引だが、task_b 用のウィンドウを書き換えるやつは task_b しかいないので大丈夫なはず。
いやまあ覗くやつ（`LAYER_MANAGER`）はおるんから微妙なんやけど。

それで大丈夫かな～と思ったらまだ起こる。
で、よくよく見ていたら、そういえば当たり前だが `printk` でもレイヤーマネージャのロックを取得する。
ということで、`printk` の前後に `cli`, `sti` を入れるようにした。
それで大丈夫かな～と思ったら、まだたまに起こる。

デバッガを起動したところ、そこで止まったの初めて確認したけど、
`MEMORY_MANAGER`（メモリ割り当てとかをする）とこで止まっていた。
確かに。

ということでここも場当たり的に前後に `cli`, `sti` を入れることで強引に解決した。
強引すぎる。
まあ最初やし一旦いいか。

最初から書き直して～。

## 2. アクティブウィンドウ

最初は `WindowTrait` 的なものを用意して、`Box<dyn WindowTrait>` を使いまわそうとして実装していたが、
それでは `LAYER_MANAGER` というか `Layer` から `Window` を貰うときに困るということに気がついた。
なので、今までの `Window` を `WindowBase` とし、列挙型の `Window` を使うことで解決しようと思う。

あと、`ActiveLayer` を作る意味が一旦わからないので、`LayerManager` で管理することにした。

## 3. ターミナルウィンドウ

`Layer` と `Window` の設計をミスっている気がするので、ちょい直した。

根本的に色々変更してもうちょい教科書に近づけようと思う。
そのためにまず起動してすぐに初期化をし、そのあとは読み取ることしかしない `OnceStatic` という型を作った。

`OnceStatic` の実装をするのに `MaybeUninit<T>` のドキュメントを読んでいたら、
`MaybeUninit` がドロップされても `T` はドロップされないので、手動でデストラクタを呼べと書いてあった。
考えてみればそれはそうで、`MaybeUninit` は初期化されてない状態のままドロップされうることもあるわけで、
この場合に勝手にデストラクタを呼ばれても困る。

ということで、`OnceMutex` と `OnceRwLock`, `OnceStatic` に `Drop` を実装した。

`Window` は保持しているプロセスが常に上書きする可能性があり、
`LayerManager` が描画時に読むという仕組みで描画しているが、
これを `Mutex` でラップして、
プロセスが描画していないことを毎回確認する運用をするのは流石にアホらしい気がするので、
書き込むようの参照は1つしか取れないが、同時に読み取る用の参照を作っても良いラッパーを作ろうかなと思う。
プロセスがウィンドウの描画中に長時間スリープする可能性がある場合にこの方法は危険
（というか変なとこで表示されたりされなくなったりする）が、
現状はそんなに長時間ウィンドウを持っているタスクが動かないということはないはずなので、
一旦これで行く。
（というか教科書はそうやしな）
普段使われている OS はどう実装しているんですかね？
[X Server](https://gitlab.freedesktop.org/xorg/xserver) とかのコード読むべき？
[Wayland](https://gitlab.freedesktop.org/wayland/wayland) でもいいかも。

上で書いたやつを `SharedLock` として実装した。（名前もうちょいいいのない？）
それを使って、`Layer` の `window` を `Arc<SharedLock<Window>>` と変更した。
