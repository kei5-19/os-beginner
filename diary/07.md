# 7日目

## 1. 割り込み（osbook_day07a）

[作って理解するOS x86系コンピュータを動かす理論と実装](https://gihyo.jp/book/2019/978-4-297-10847-2) を一通り読んでいるので知っている。

## 2. 割り込みハンドラ

同じく。
ただ C++（もしくは clang）の機能である `__attribute__((interrupt))` というのが出てきた。
コンテキストスイッチ処理をコンパイラが挿入してくれるらしいが、恐らく stable Rust にはない。
[#40180](https://github.com/rust-lang/rust/issues/40180) で実装予定っぽそうだが、今はなさそう。
なのでコンテキストスイッチは自分で書かないといけなさそう。
幸い前期に受けた OS の講義で見たことがあるし、13章にも載っているそうなので、そこらへんを参照して書く予定。

## 3. 割り込みベクタ

これも知っている。
と思っていたが、なんか x86 のときと比較してセグメンテーションの機能が弱くなっているっぽい？
メモリを区画に分ける機能が無効化されているとか言われて困惑している。
どう使ってんだ？
まあ今後学ぶのを楽しみにしておきます。

ただ、割り込みディスクリプタが、アドレスが 32 bit より多くなっている都合で、
x86 のときと比べて大きくなっている（倍になっている）。
まあ、増えたうちの半分は予約領域らしいけど。

あと、またビットフィールドと `packed` が出てくるので、それ用の処理は書かないといけない。

## 4. 割り込み記述子の設定

これも IDT (Interrupt Descriptor Table) の先頭アドレスが 64 bit になっている以外は
x86 と同じなので履修済み。

## 5. MSI 割り込み

これは知らない。

PCI 規格では割り込み信号線が4本しかなく、複数端末から割り込みが発生する場合は苦労したらしい。
ただ今は MSI (Message Signaled Interrupt) というのが採用されて不便はなくなったそう。
これは、信号線等を使うのではなく、CPU がメモリアドレスの一部を内部のレジスタに転送していて、
そこへの読み書きによってやり取りするというものらしい。

ここで大事なのは Message Address レジスタと Message Data レジスタの設定。
この設定でどの CPU コアに割り込みを通知するか、割り込みベクタをいくつにするかを決められる。

この2つのアドレスがメモリのどこにマップされているかという話があるが、
実装を真似たところ PCI コンフィギュレーション空間に書いてあるみたい。
多分これについては [pci.rs](../mikan-os/kernel/src/pci.rs) の `configure_msi()`
関数を見ると分かると思う。

あと CPU コアだが、起動時はシングルコア（BSP (Bootstrap Processor) と呼ぶ）で起動している状態で、
この教科書はコアを1つしか使わないそうなので、この BSP をそのまま用いる。
このコアの ID は `0xFEE0_0023` に書かれているらしい。

## 6. 割り込みのまとめ

### なぜ当初上手く行かなかったか

最初全く割り込みが発生しなくて困った。
この確認は割り込み関数 `int_handler_xhci()` の先頭に何かしらの文字列を表示するようにして行った。

で、その理由だが、packed 構造体の要素への参照は未定義だと言われ、生ポインタを使うようにしていたが、
生ポインタからメソッドを呼び出したりするのも未定義。
で対処法は、同じ構造のものを用意して、それをそのまま

```rs
unsafe { p.write_unaligned(value) };
```

というように書き込むことらしい。
これを知ったときにこの `write_unaligned` の実装を見てようやく理由がはっきり分かった。
このメソッドの中身は、ただ `value` を1バイトずつ `memcpy` でコピーしているだけ。

なぜこのような実装になっているかというと、大抵の CPU（もしかして全ての CPU？）には
n バイトの領域にアクセスする（例えば4バイト整数に演算を行ったりする）とき、
アドレスを n の倍数にしてアクセスしなければならないという決まりがある。

ここで packed な構造体、例えば

```rs
#[packed]
struct Struct {
	a: u8,		// offset = 0
	b: u16,		// offset = 1
	c: u8		// offset = 3
}
```

のようなものを考える。
するとこれは全体が4バイトなので、4の倍数のアドレスに配置されるだろうが、
2バイト整数の要素 `b` は、奇数アドレスに配置されることになりさっきの条件を満たせない。
そのため1バイトずつアクセスするしかないということになる。

これで [pci.rs](../mikan-os/kernel/src/pci.rs) の `configure_msi_register` を書き換えたところ、
正常に動作するようになった。

### \_\_attribute\_\_((interrupt)) の代わり

さっきの修正で正常に動作するように見えたが、
割り込み関数用の呼び出し規則を用いなければ、
1回目の割り込みが終わったあと元の処理に戻れないので確認できない。

これは、割り込みからの復帰には `iret`（x64 では `iretq`）を用いる必要があり、
このときスタックへの積み込みが普通の関数呼び出しと異なるから。
あと現在の状態の保存とかもしないといけない。

それでそれを Rust の [Attribute-like macro](https://doc.rust-lang.org/book/ch19-06-macros.html#attribute-like-macros)
を用いて実装しようと考えました。
具体的には、[custom-attribute](../mikan-os/custom-attribute/) を見てもらえば分かると思いますが、
まずインラインアセンブリで現状の保存、引数（InterruptFrame）の用意、
割り込み関数の呼び出し、割り込み前の状態の復帰を行うものを出力。
そしてそこから呼び出せるように、元の関数に少し手を加えるということを行いました。

そのときにある程度もとの `__attribute__((interrupt))` を元にしたほうがいいだろうと思い、
テスト用のコードを書いてコンパイル結果を眺めてみた。
すると、C++ では 少数計算用のレジスタの保存とかも行っていたっぽい。
理由は C++ では整数演算しか行っていないときでも、少数演算を行うバイナリが出力されることがあるかららしい。
Rust であるのかは知らないが、まあ滅多にないだろうというのと、
Rust はそういう今年なさそうという偏見から、整数レジスタしか保存してない。

このときに x64 でお世話になった `pusha` 命令を使おうと思ったのだが、
x64 ではレジスタが増えすぎたからか `pusha` が消えたらしい。
ので、泣く泣く全部手打ちすることになりました。

参考：[Rustのcustom attributeチュートリアル](https://qiita.com/dalance/items/1911a775ee23f3e35d18)

あと、なんか vscode で `proc macro not expanded` みたいなのが出てきて、
まあコンパイルは通るので問題ないといえば無いんですが、
鬱陶しかったので [proc macro not expandedエラーが出たときにやったこと](https://qiita.com/flu_bit/items/ef1f5726e7c598526aa0) を
参考に消した。
ただ、vscode の警告を消しただけで根本的な解決にはなっていないので、少し気持ち悪い。

### 結果

ここまでやったら正常に動くやろ～って思ってたんですが、
なんか登録時の1回（実機で試したら2回）しか割り込みが発生しなかった。

いろんな設定値がちゃんと設定されているかとか、
アセンブリとにらめっこしたりとかして色々調べたんですが、
解決策は分かりませんでした。
USB ドライバ側の問題な気がしなくもないけど、他の人をいくつか調べてみても
みんな動いていそうだったので、まあ自分が悪そう。
ただ原因はこれ以上時間喰っても仕方ないくらいには調べて気がするので、
一旦諦めることにします。

## 7. 割り込みハンドラの高速化（osbook_day07b）

ここまでの実装では、割り込み関数内で処理を行っている。
しかし、割り込み関数内ではハードウェア割り込みが禁止されるため、
重い処理を行うと割り込みを取り逃してしまう可能性がある。

そこで割り込み関数内では、割り込みがあったことを記録しておくだけにしておこうという話。

## 8. FIFO と FILO

まあこれはデータ構造の話で元々知っていた。
まとめると

- FIFO は First In First Out の略（キューのこと）
- FILO は First In Last Out の略（スタックのこと）

割り込みの保存は、来たものから処理するものなので FIFO で扱う。

## 9. キューの実装

教科書では、C++ には元々キュー用のクラスが存在するが、
それはヒープ領域を使用するため自作するという話だった。

これは C++ ではなくて Rust を用いているが、現状でヒープが使えないのは同じなので、
同様にヒープを使わないバージョンを実装する。

## 10. キューを使った割り込み高速化

割り込み関数をキューに追加するように変更して、
カーネルの最後でキューの中身があるかないかのループを回し、
中身があればこれまでの割り込み処理を行うような実装を行えばいい。

ただ、2つだけそのままではないところがある。

1つ目は重要で、キューの中身を確認する間は割り込みを禁止しておくということ。
理由はデータ競合を防ぐため。
詳細は省くが、キューの中身を確認、取り出し中に割り込みが起こるとデータがおかしくなってしまう場合がある。
Rust ではそれを禁止するようにデータ構造を作るのが普通だが、
面倒だし、そもそも割り込み関数は処理が終わるまで他の関数に処理を移したりしないので、
データ更新ができない状態で割り込み処理に入ると、なんにもできなくなってしまうため、
そうしないほうが良さそうな気がする。

2つ目はそこまで重要ではないが、CPU の負荷軽減のためには大事で、
キューの中身がなかったときは、そのあとに `hlt` 命令を呼んでおく。
この理由は、`hlt` 命令中は割り込みがあるまで CPU の処理が停止し、省電力状態になる。
逆にこれをしないと、割り込みがないときもループのために永遠に `jmp` 命令が呼ばれることになる。

### 補足

ここまでで動くようになるはずだが、まだ動かない。
まあ割り込みが1回しか発生しないのだからそれはそう。
なんでやろうな～。
分かりません。

あとは、そろそろリファクタリングをしたほうがいい気がするが、
次の第8章はメモリ管理の話で、それを早くやってしまいたいので、一旦飛ばすことにする。
メモリ管理できるようになったら、大分できること増えるやろうし、アツい。
