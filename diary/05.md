# 5日目（2023/11/30）

## 文字を書いてみる

特に言うことなし。

## 分割コンパイル

これも元々ある程度分割してあったし、特に言うことなし。
ただ、Rust において分割コンパイルが行われるのかはよく分からない。

## フォントを増やそう

これは、本来は python スクリプトを使ってオブジェクトファイルを生成するらしいが、
わざわざオブジェクトファイルを面倒な方法で参照するのはアホらしい気がした。
そこで生の Rust ファイル
[font_data.rs](../mikan-os/kernel/src/font_data.rs) に、
[hankaku.txt](https://github.com/uchan-nos/mikanos/blob/osbook_day05c/kernel/hankaku.txt) から
VSCode の置換機能を使って `get_font()` 関数を実装した。

## 文字列描画と ~~sprintf()~~ write!

文字列を描画すること自体は教科書ほぼそのまま。
ただし、Rust のスライス（広義の配列）は C の配列と違い、そのサイズ情報も持っているので、
文字列をヌル終端する必要はない。

`sprintf()` の方は少し工夫が必要だが、すでにローダのところでも似たようなことをやった。
教科書では、NewLib という OS が入っていない環境でも簡単に使える C の標準ライブラリを使っているが、
それはできない。

恐らくそれに相当する Rust のライブラリは [core](https://doc.rust-lang.org/core/index.html) クレートにあるので、
それを使っていくことになる。

今回は `sprintf()` の代わりに、`core::fmt::Write` トレイトを用いる。
このトレイトを実装した型の変数 `buf` に対して、`write` マクロを用いて `sprintf()` 同様に

```rs
write!(buf, format_string, arg1, ...)
```

とできる。
そこで `Write` トレイトを実装した型 `StringU8` を作り、それで試している。

## コンソールクラス

これもそんなに考えることはない。
ただ教科書では、`Console` クラスが保持する配列が `(列 + 1) x 行` になっているが、
これは列の1番最後にヌル文字を持つためだが、Rust ではその必要はないので単純に `列 x 行` にしてある。

あと、最後の27行表示するところで、行数が25なのに24行しか表示されてなくて、おかしいなと思ったが、
最後に改行文字が入っているせいでした。
アホすぎる。

## printk()

これは、Rust では可変なグローバル変数を用意するのが大変なため、難しい。
調べたり、なんか書いてみたりしたが、すんなり進まない。

- https://gifnksm.hatenablog.jp/entry/2021/05/09/155149
- https://os.phil-opp.com/ja/vga-text-mode/

ここらへんで行けそうだが、あんまり理解せずにコピペしても駄目だった。
ちょっと諦めて、必要なときは `console` の参照を回していこうと思います……。
どっかでガチ理解男になったら実装する。
