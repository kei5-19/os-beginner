# 14日目

<!-- mtoc-start -->

- [1. スリープしてみる](#1-スリープしてみる)
- [2. イベントが来たら起床する](#2-イベントが来たら起床する)
- [3. タスクに優先度をつける](#3-タスクに優先度をつける)
- [4. アイドルタスク](#4-アイドルタスク)

<!-- mtoc-end -->

## 1. スリープしてみる

教科書では `Task` のポインタからでもスリープしたりできるようにしているが、
とりあえずこちらは `id` しか受け付けないようにした。

あとは、`TASK_MANAGER` の使い方がだいぶ怪しいが、まあ教科書と同じなので大丈夫ではあるはず。
ただ、同じタイミングで同じタスクに対して `sleep()` とか `wake_up()` 呼んだらまずいやろなあ……。
まあシングルコアやし、最初の方に初期化しておしまいやから今は大丈夫（なはず）。

## 2. イベントが来たら起床する

ここの機能がメインタスクへの描画依頼に必要。

~~教科書のミスじゃない？ポイント発見。
リスト 14.14 で~~

```cpp
__asm__("cli");
auto msg = main_task.ReceiveMessage();
if (!msg) {
    main_task.Sleep();
    __asm__("sti");
    continue;
}
```

~~ってあるんやけど、ここの `Sleep()` と `sti` 逆じゃないか？
スリープさせると別のタスクに移動するはずで、
そうすると割り込みが許可されないまま別のタスクに移ってしまうことになる。~~

と思ったけど、コンテキストスイッチのときにフラグが移動先のコンテキストのもので設定し直されるから大丈夫や。

## 3. タスクに優先度をつける

Rust ではあまり上手く書けなさそうで、ところどころ実装方法が違う。
からなのか、またよく分からんバグに遭遇。

今度は XHCI デバイスの割り込みが発生しなくなっているらしい。
なんじゃこれ。

めっちゃアホな理由やった～。
スリープさせるときにタスクの running を `false` に設定し忘れてました。

でも今度はマウスを動かしたりするとたまにデッドロックするように。
調べてみた感じ、`LAYER_MANAGER` の問題っぽいし、毎回発生するとうわけでもないっぽいので、
15章ので解決することにする。

あ、あとは教科書と違って、`init()` 関数内で直接 `TASK_MANAGER` の `running` リストに
タスクを突っ込むんじゃなくて、`wake_up(-1)` を使って登録をしている。
こっちのほうが楽やと思う。

## 4. アイドルタスク

デッドロックが目立つ！
けどまあそれ以外は問題なさそう。

一応作ったアイドルタスクに `printk` 入れてみたけど、
ちゃんと task_b がスリープされたときだけ呼び出されていて素晴らしい。
