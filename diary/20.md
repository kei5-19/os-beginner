# 20日目

<!-- mtoc-start -->

- [1. アプリが OS の機能を使う方法](#1-アプリが-os-の機能を使う方法)
- [2. OS を守ろう (1)](#2-os-を守ろう-1)
- [3. TSS を設定しよう](#3-tss-を設定しよう)

<!-- mtoc-end -->

## 1. アプリが OS の機能を使う方法

カーネルのデバッグ情報を見て使いたい関数のアドレスを読み、
それを直接外部アプリから呼び出してみようという話だが、
ちょっと C++ よりもやりづらい（ヘッダーファイルのインクルードとかはない）ので
パスする。
どうせここの実装が最終的な OS に入るわけではないし、どうやるのかは分かるし。

## 2. OS を守ろう (1)

戻るときのスタックの状態をいつもこういうの全部忘れるからまとめる。

- far return（`retf`, `CB`）

```text
| rip |
| cs  |
| rsp |
| ss  |
```

- interrupt return（`iret`, `CF`）

```text
| rflags |
|   rip  |
|   cs   |
```

x86 の方の本を呼んできたが、あちらはタスクの呼び出しを TSS を使って呼び出し、
`iret` で戻るというように実装していた。
もう覚えてなかったが、説明を読んだ感じ TSS の link フィールドに前のタスクの CS を保存して、
`rflags` の NT フラグを立てる。
で `iret` で戻れるらしい。
ということは多分、NT フラグが立っているかどうかで `iret` の挙動は変わって、
立っていなかったら、スタックから RIP, CS を取り出して戻る。
立っていたら、現在の CS が TSS のはずで、その link フィールドを CS に設定する。
ということをやっていそう。
なんかマニュアル読んどったら、これできるのは protected mode だけらしい。

intel の x64 のマニュアル読むと、モード名がよく出てくるが、モード名も良くわからないのでここで整理。

| モード名 | フラグの状態 | 説明 |
| :---: | :---: | :---: |
| real mode | CR0.PE = 0 | 16ビット。8086 と同じ |
| virtual-8086 mode | CR0.PE = 1 and FLAGS.VM = 1 | x86（i386 とか）で 8086 をエミュレート |
| protected mode | CR0.PE = 1 and FLAGS.VM = 0 | 32ビット。x86 状態 |
| IA-32e mode, long mode | CR0.PE = 1 and FLAGS.VM = 0 and EFER.LMA = 1
| x86_64 の64ビットモード。現在の普通の状態はこれ |

x86 の方の本で protected mode にする方法は学んだが、long mode にする方法は知らないので、
一旦ここでまとめておく。

1. CR4 の PAE（Physical Address Extension）をセットする
2. ページングディレクトリを CR3 に設定
3. CR0 の PG（PaGing）, PE（Protection Enable）を有効化
4. EFER（Extended Feature Enable Register）の LME（Long Mode Enable）をセット
5. 64ビット用のセグメントに far ジャンプする

gdb で見た感じ、ここらへんは全部 UEFI がやってくれるっぽい。
今の教科書でこういう設定は全くやっていないのでそのはず。
なにもんすぎる。

この章で得た新たな情報としては、
paging の user フラグは DPL = 3 のセグメントからアクセスできるかどうかを表すらしいということ。
これでリングレベル3からの保護はできるけど、リングレベル1, 2からの保護はどうするんやろ。
なんとなくリングレベル1, 2ではドライバとかの低レイヤーよりのことをさせるんやろうなと想像しとるけど、
そこからはなんにも保護せんくていいんか？

x86 の時代ならセグメントディスクリプタとページングを合わせれば保護できたと思うけど、
x64 ではセグメントの機能がほぼ死んどる（アドレスの制限ができない）から、
ページングで保護するしかないと思うんやけどなあ。

まあどうせここらへんの教科書ではリングレベル1, 2を使うことはないから、
Linux カーネルとかのソースコード見るくらいでしか学べんのやろうな。

あとは1箇所上手く動かないところがあった。
途中で CPU 例外が発生するはずやけど、gdb で rpn のプロセスが始まるかどうかは確認しようとしたら始まらない。
`retf` で失敗しているのは分かったので、セグメントもセグメントディスクリプタも何回も確認したが正しそうだった。
なにがおかしいのかと唸っていたが、どこかでも CS と SS をページングを自分で設定したものに変えるために
同じことをしていたはずだと思ったので確認しに行った。

そうしたところ、コンパイラに

```asm
o64 retf
```

と書いて怒られたから

```asm
retf
```

としていたが、これでは同じ意味にならなくて（普通に考えてそう。なぜ確認を怠ったのか……）、

```asm
retfq
```

としなければならないことを思い出した。
そういえばこれ周りのことちゃんと obsidian でまとめたはずだったのに……。（アホ）
ちなみに `CB` という命令にプレフィックスの `48` がつくらしい。

## 3. TSS を設定しよう

なんか TSS の使い方すごい変わっとる。
なにが起きたんや？
セグメントに変化があったのはまあ分かるけど、TSS はなんでや？
まあこれもあんまり使われんかったんかなあ。

あと LDT については全く説明されていないけど、
復習した感じ、x64 では LDT もあんまり使われてないんちゃうかなという気がしてきた。

あとは、TSS と LDT の GDT 上でのサイズは2倍になったらしいです。
