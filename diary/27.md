# 27日目

<!-- mtoc-start -->

- [1. デマンドページ](#1-デマンドページ)
- [1.5 スタックの伸長](#15-スタックの伸長)
- [2. メモリマップトファイル](#2-メモリマップトファイル)
- [3. メモリ使用量を測ろう](#3-メモリ使用量を測ろう)
- [4. コピーオンライト](#4-コピーオンライト)

<!-- mtoc-end -->

## 1. デマンドページ

まず、`custom_attribute` に自前で実装した割り込みハンドラのプロローグ、
エピローグの処理が間違っていたので修正した。

まず今まで多分割り込みハンドラの処理でそんな変なことをしていないから問題が起きていなかったが、
関数呼び出しの前の RSP を16の倍数に調整して置かなければならないのを忘れていた。
（今回も別にこれで問題が起きたわけではない）

あとこっちが致命的で、どこかのタイミングでエラーコードがある場合の処理を追加したが、
このとき割り込み後のスタックが

```text
| error code |
|     RIP    |
|     CS     |
|   RFLAGS   |
|     RSP    |
|     SS     |
```

というように積まれているので、エラーコードがない場合と違って `iret` の呼び出し前に
RSP を +8 しないといけないが、それを忘れていた。
そのせいで今まで見たことない `iret` での一般保護例外が出てビックリした（CS とかの値がおかしいと出るらしい）。

あとは AT&T シンタックスと intel シンタックスに騙されました。
CR2 を取得するのに（intel シンタックスで）

```asm
mov rax, cr2
ret
```

みたいなことをしないといけないが、最近どちらも見るせいで逆に書いてしまっていた。アホ。

デマンドページングシステムコールを追加したことで、
アプリ側でもページ割り当てが行えるようになったので、
app-lib に `global_allocator` を追加した。
ただし、ライブラリに `global_allocator` を実装すると、
柔軟性が効かなくて困りそうだなと思って色々と調べた感じ、
こういうことに feature を使えばいいことに気がつけた。

ということで、まず alloc feature をオンにすると
`alloc` クレートを使うようにし、`GlobalAllocator` を実装した `Global` を提供する。
そして global_alloc feature もオンにすると（勝手に alloc feature もオンになる）、
`global_allocator` として宣言した実体の `Global` を使えるという風にした。

いや～、feature 便利ですね。

で、これまでのアプリは `alloc` クレートが使えなくても動くものだから、
テストも兼ねて app-lib の default-features をオフにしておいた。

その上で、app-lib で alloc feature がオンになっている場合は
今まで固定長のバッファでやりくりしていたところを `Vec` とかを使うように変更した。
これで滅多なことではエラーにならないはず。

## 1.5 スタックの伸長

次にメモリマップトファイルをやることになっているが、
その前に、前に言っていたページフォルトでスタックを伸ばすというのを実装する。

ここに持ってきた理由は、
教科書ではメモリマップトファイルがアプリ用スタックの真上（アドレス的には下）を使うことになっていて、
そこをずらさないといけなくなるから。

今 WSL の環境でデフォルトのスタックサイズを確認したところ、8MB だったのでそれを真似る。
あと `ulimit -s <size>` で変えられるらしいので、これも真似た。

これをテストしようと `large` アプリに長い配列の宣言を書いたらなんか怒られた。
見たがなんかよく分からんとこでアドレス 0 にアクセスしようとしていて俺のせいではないやろってなった。
よく見るとコマンドライン引数を数値に変換しているとこでミスっていそうだったので、
コマンドライン引数の数を返すようにした `stack` アプリを新規に作った。
そうしたところ上手く行った。

あと `ulimit` のテストも兼ねて、
スタックサイズを配列より小さくしてみたらちゃんとエラー終了したので問題なさそう。

## 2. メモリマップトファイル

途中で、print デバッグすると `Some` やのに、
その後使おうとすると `None` になるとかいう意味不明なことが起きた。
まあ多分 UB 踏んだんやろうなあと思って調べていると、

```rs
let file_size: &mut usize = unsafe { core::mem::transmute(pfile_size) };
```

というのが駄目だった。

今まで必要に駆られたとき以外は基本キャストを使っていたが、最近間違えて `transmute()` 使ってしまう。
ただこれがなぜ UB なのかあんま分かってない。
サイズは同じはずやしなあ……。

[`transmute()` の説明](https://doc.rust-lang.org/std/mem/fn.transmute.html) を読むと、
`const` 文脈ではあかんって書いてあるけど。
と思ったら、そのちょい下に最近は UB と考えられるようになってきたって書いてありましたわ。
「最近は思われるようになってきた」ってなに？
UB って定義されているものというか、
UB じゃないものが定義されていてその補集合が UB っていうわけじゃないのか……。
よく分からんけど、まあ `transmute()` には気をつけよう。
（同じようなことを今回他の関数実装するのにも使ったけど大丈夫かな……）

## 3. メモリ使用量を測ろう

特になし。

## 4. コピーオンライト

x86 のときは TSS を使ってやったけど、ページングでやると。
やっぱ大体の仕事はページングにやられるようになった感じやな。

R/W フラグをオフにしておいて、書き込みがあったページはグローバル変数が置いてあるから
アプリごとに個別のコピーを作るけど、それ以外は共有するという話。
実用的な OS はリロケーションでそもそもグローバル変数とかが置かれる場所が
命令とは別のページに入るようにされていて、
命令部分はコピーせず使えるようになっとるんじゃないかな～という気がする。
まあリロケーションしないタイプのバイナリを動かすときは同じ仕組みかな？
