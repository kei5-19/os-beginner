# 11 日目

<!-- mtoc-start -->

- [1. ソースコード整理](#1-ソースコード整理)
  - [1.1 `lib.rs` の作成](#11-librs-の作成)
  - [1.2 clippy に基づく整理](#12-clippy-に基づく整理)
  - [1.3 CMake の使用](#13-cmake-の使用)
  - [1.4 デッドロックの回避（中途半端）](#14-デッドロックの回避中途半端)
- [2. タイマ割り込み](#2-タイマ割り込み)
- [3. 細かく時間を計る](#3-細かく時間を計る)
  - [3.1 Mutex, OnceMutex の変更](#31-mutex-oncemutex-の変更)
- [4. 複数のタイマとタイムアウト通知](#4-複数のタイマとタイムアウト通知)
- [5. ACPI PM タイマと RSDP](#5-acpi-pm-タイマと-rsdp)

<!-- mtoc-end -->

## 1. ソースコード整理

教科書がソースコードの整理をしたらしいので、こちらもそれに倣う。
ただ、こちらは Rust で実装しているので、他にも色々した。

### 1.1 `lib.rs` の作成

今までは全てバイナリクレートとして実装していたが、
`lib.rs` を作り、メイン処理の `main.rs` 以外のファイルは全てライブラリ側のモジュールとした。
これによって `pub` 宣言しているのに使われていないものの警告が全部消えた。嬉しい。

### 1.2 clippy に基づく整理

Rust には Clippy というリンターがあるが、それを `kernel` に対して行うレシピを追加し、
その警告等がすべて消えるように少し修正を行った。

### 1.3 CMake の使用

これまでは C++ ソースコード（ドライバ）のビルド、リンクに
[cc](https://crates.io/crates/cc) を使用していたが、
恐らくこれは C++ 側のコードに全く変更がなくても、
Rust のコードに変更があるたびに全ファイルのコンパイルを走らせる。
それでビルドが結構遅いのが気になってきたので、解消方法を色々と調べていた。

すると [cmake](https://crates.io/crates/cmake) が出てきた。
最初に C++ ファイルをビルドしないといけなくなったときにも出てきたが、
知らない CMake を導入するのが面倒そうで、スルーしていた。
でもこちらを導入すれば要らないコンパイルは走らなくなりそうだな～と思ったので、
思い切って導入してみることに。

それで分かったけど、これくらいの用途に使う分にはそんなに CMake に面倒はない。

で実際どうかというと、多分結構速くなった。ありがたい。

### 1.4 デッドロックの回避（中途半端）

Rust では可変な静的変数（`static mut`）が未定義動作なので、
（現状シングルスレッドやし、割り込みがあるとはいえ問題は起こらんと思うけど、）
一応 `Mutex` 的なものを使うようにしている。
ただそうすると、当たり前のようにデッドロックが起こる。
特にフレームバッファを触る系のオブジェクトのロックを取得している途中で `panic` とかが発生すると、
何も表示されずにただ止まるのでキツい。

解決策としては、

- `panic` を禁止にして、`Result` を持ち回すようにする（多分これが一番 Rust らしい）
- static にするオブジェクト自体を `Mutex` にするのではなく、その中に `Mutex` 変数を持たせる
  （多分これもやったほうが良い）

っていうのがあるが、もうだいぶ進んでいてどんどん面倒になってきている。

なので、一部だけ解消したが、面倒すぎて一旦ストップしている。

ただ一番酷かった、`panic` の内容が表示されないというのは、
`panic` を表示する用のコンソールを新しく作って、それに表示することで（多分）解消できた。
無理やりやけどまあええやろ。

あと、これを書いている途中で `panic_handler` の中で `CLI` を呼ぶべきだということに気がついたので、
それも足した。

## 2. タイマ割り込み

特に言うことなし。

ただ、タイマー割り込みで周期的に設定したときは、カウンタが 0 になるたびに、
設定してある初期値を毎回読み込むらしい。

## 3. 細かく時間を計る

これも特に言う事無し。

ただ（またか）、せっかく `Mutex` を使っているのに、わざわざ `TIMER_MANAGER` の読み込みで
`cti` と `sti` を呼び出していてアホらしいかもしれない。
しかし現状は `Mutex::lock()` がスピンループになっているので、
こうしないとデッドロックが起きる。
ただのマルチスレッドなら問題ないが、
シングルコアでの割り込みでロックが取れるまで待機したらそこで終わってしまう。

`Mutex::lock()` と `Mutex::lock_wait()` とかを用意したほうがいいかもしれない。

### 3.1 Mutex, OnceMutex の変更

ということで、`Mutex` と `OnceMutex` の2つに `lock()` と `lock_wait()` を追加した。

あと、`lock()` を使って `TIMER_MANAGER` のロックを取得する前後の割り込みの禁止を削除した。
軽くテストしたけど、大丈夫そうな感じがした。

## 4. 複数のタイマとタイムアウト通知

タイムアウト通知は割り込みとかと同じで `Message` を使って通知するらしい。
そこで `Message` のフィールドに `union` を入れたいらしく、
そのために `Message` と `MessageType` を分離していたことが分かった。
なので、とりあえずその分離を無くして、教科書が `union` でやっていることは、
こちらは `enum` で対処することにする。

あとは、教科書では `TimerManager` に `main_queue` への参照を持たせているが、
こちらはもともと static 変数として用意しているので、構造体のメンバーとしてもたせるのではなく、
直接 static 変数にぶち込んで解決している。

## 5. ACPI PM タイマと RSDP

久しぶりに [mikan-loader](../mikan-os/mikan-loader) の方を触った。

なんか教科書には `gEfiAcpiTableGuid` という EDK-II で定義されている値が出てきたけど、
uefi-rs では定義されていなさそうだったので、無理やり
[EDK-II のを]
(https://github.com/tianocore/edk2/blob/948f23417010309a5557d46195eae258f6105025/MdePkg/MdePkg.dec#L380)
引っ張ってきた。

あと、書いている途中で `loop` 文では

```rs
let value = loop {
    if cond {
        break item;
    }
    ...
};
```

というようなことを書けば、`value` は最初に `cond` を満たした `item` にできるけど、
`for` とか `while` でできたりせんのかな～と思った。
（まあそのためには、最後まで値が決まらなかった場合を書かないといけないが、その方法がないという
話だとは思うが、別に `else` とかでなんとかなるやろと思っていた）
そしたらそういう [isseu](https://github.com/rust-lang/rfcs/issues/3361) があった。

それを見ていたら、 なんか

```rs
let value = `block: {
    for item in items {
        if cond(item) {
            break 'block Some(item);
        }
    }
    None
};
```

っていうのが書けることを知った（まあこれくらいなら、`Iterator::find()` でいいんやけど）。
issue 眺めるだけでも勉強になるんやなあ（そりゃそうか）。
