# 21日目

<!-- mtoc-start -->

- [1. IST を設定しよう](#1-ist-を設定しよう)
- [2. 文字列表示システムコール](#2-文字列表示システムコール)
  - [2.1 アプリ用ライブラリ作成](#21-アプリ用ライブラリ作成)
- [3. 終了システムコール](#3-終了システムコール)

<!-- mtoc-end -->

## 1. IST を設定しよう

教科書の最初の方にこの本では IST は常に0ですって言っとったけど、バグ起きる前に書いたんやろなあ。
（最後の章でバグ起きてこの章とかは付け足したらしいです）

IST は TSS に設定するスタックのアドレスで、7個まで指定できる。
その7個（1-7）もしくは0を IDT の IST に指定すると、
その割り込みに関しては IST で指定したスタックが使われるようになる。

## 2. 文字列表示システムコール

C とか C++ で書かれているものと同じ進め方で Rust で実装していくのむずい！
やっぱり Rust はある程度完成形が見えてないと書くの厳しいんかなという感じがする。

すみません、考えるのがだるくなったし、このままの `Terminal` のメソッドからアプリを実行するというスタンスでは、
`Mutex` とかを使ってもできんし、
（まあ `Mutex<Terminal>` から呼べばいいだけやけど）ほんまにアドレス渡したろうかという気になってきています。

それはさておき、map が要るとのことで、順番付けが大事ってわけでもないので、
`HashMap` を使おうとしたんですが、なんか Rust の `HashMap` は環境のランダム性を必要とするらしく、
`std` 環境でないと使えないらしい。
まあ別に `BTreeMap` 使えばいいんやけど、[chibicc](https://github.com/rui314/chibicc) 見たときに
簡単な `HashMap` くらい書いてみたいなと思っていたので、
これを参考に（というか丸パクリして）[collections](../mikan-os/kernel/src/collections.rs) に書いてみた。
[FNV ハッシュ](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) とかいうのを使った。

あとテストしないのは良くないという話があって（今まで全くしてなかったけど）、
`no_std` 用でもちゃんと準備すれば `std` 環境を使ってテストできるらしいけど、
今からそうできるように修正ていくのは大変そうだったので、
debug 状態で動かすときにカーネルの途中でテストを挟むことにした。

`setup_page_maps()` の `phdr.vaddr` が 4KB 境界に整列されているわけではないため、
と `(phdr.vaddr & 0xfff) + phdr.memsize` が 4KB を超えているとバグる状態だったため、修正した。

アドレスを直接保持することにしたから、`move` とかが起きただけでヤバいけど、まあ一旦これでいかせていただく。
まあ `Mutex` 使うべきなんやろなあ。

### 2.1 アプリ用ライブラリ作成

今後もアプリ作るんかもしれんし、ライブラリ作った。
`global_asm!` に `.global <name>` を入れ忘れたせいでリンクできんくてずっと「？」状態やった。
アホすぎる。

あとはアプリのエントリーポイントの処理をプロセスマクロにしたいかも。

実装したライブラリを使って楽に rpn から結果を表示できるように。
あと、デフォルトのエントリーポイントが `_start` らしく、
エントリーポイントの指定要らんらしいから消した。

## 3. 終了システムコール

復帰のためにもらう `stack_ptr` についてですが、絶対良くないけど、`&mut u64` ではなく `&u64` を渡すことにします。
（そうじゃないと今の構成で `Task` からもらうのは無理）
あとは Exit Code を受け取って表示するように変更。
